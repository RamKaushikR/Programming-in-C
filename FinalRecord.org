#+AUTHOR: R Ram Kaushik

#+LaTeX_HEADER: \usepackage{palatino}
#+LaTeX_HEADER: \usepackage[top=1in, bottom=1.25in, left=1.25in, right=1.25in]{geometry}
#+LaTeX_HEADER: \usepackage{setspace}
#+PROPERTY: header-args :exports both :eval no-exports
#+OPTIONS: toc:nil
#+OPTIONS: num:1
#+STARTUP: showeverything
#+begin_latex
%\linespread{1.2}
#+end_latex
*Ex02*
* Objective
   1. Translate expressions to C.
   2. Declare variables of data types appropriate for the calculation.
   3. Order the update of variables using a sequence of assignments.
   4. Use alternative and conditional statements.
   5. Specify, define, and call simple functions.

* Area and Perimeter of circle
*Problem Description:* Write a program to calculate the area and
the perimeter of a circle. Read the radius from the user and print
the outputs on the display.
** Specification
A function =area()=, which takes the radius =r= of the circle as 
input and returns the area, =perimeter()=, which takes the radius =r=
of the circle as input and returns the perimeter.
** Prototype
#+BEGIN_EXAMPLE
float area(float r)
float perimeter(float r)
#+END_EXAMPLE
** Program Design
The program consists of the 2 functions =area(float r)= which finds the area 
of the circle, =perimeter(float r)= which finds the perimeter of the circle,
and =main()= which reads the input from =stdin=, calls the functions and prints 
the result on =stdout=.
** Algorithm
#+BEGIN_EXAMPLE
def area(r):
   return 3.14*r*r
def perimeter
   return 2*3.14*r
#+END_EXAMPLE
** Source Code
#+BEGIN_SRC C :cmdline <arper.in
  #include<stdio.h>
  float area(float r){
    return 3.14*r*r;
  }
  float perimeter(float r){
    return 2*3.14*r;
  }
  int main(){
    float r,ar,p;
    scanf("%f",&r);
    ar=area(r);
    p=perimeter(r);
    printf("%f %f %f",r,ar,p);
  }
#+END_SRC
** Test Input
#+BEGIN_EXAMPLE
15
#+END_EXAMPLE
** Output
#+RESULTS:
|15.000000| |706.500000| |94.199997|

* Leap Year 
*Program Description:* Write a Boolean function =is_leap()= for testing whether 
a year is leap year or not. Test the function from =main()=.
** Specification
A function =is_leap()=, which takes the =year= as input and returns either =true=
 or =false= in bool.
** Prototype
#+BEGIN_EXAMPLE
bool is_leap(int year)
#+END_EXAMPLE
** Program Design
The program consists of a function =is_leap(int year)= which returns =true= if the 
year is leap and returns =false= if the year is not leap and =main()= which gets the
input from =stdin=,calls the function and prints the value on =stdout=. 
** Algorithm
#+BEGIN_EXAMPLE
def is_leap(year):
   if year%4==0 and year%100!=0 or year%400==0:
      return true
   else:
      return false
#+END_EXAMPLE
** Source Code
#+BEGIN_SRC C :cmdline <leap.in
  #include<stdio.h>
  #include<stdbool.h>
  bool is_leap(int year){
    if (year%4==0 && year%100!=0 ||year%400==0)
      return true;
    else
      return false;
  }
  int main(){
    int year,leap;
    while(scanf("%d",&year)!=EOF){
      leap=is_leap(year);
      printf("%d\n",leap);
    }
  }
#+END_SRC
** Test Input
#+BEGIN_EXAMPLE
2009
2000
1900
1936
#+END_EXAMPLE
** Output
#+RESULTS:
| 0 |
| 1 |
| 0 |
| 1 |
* Roots of Quadratic equation
*Program Description:*   Read the coefficients =a=, =b=, and =c= of a quadratic equation. 
Calculate the discriminant.  Define a function =sign()= that returns -1 or 0 or 1 for a 
negative number, zero or a positive number, respectively. Use it to test the discriminant. 
If the discriminant is non-negative, find the roots of the equation, and print them. Avoid 
duplicate calculations wherever possible.
** Specification
A function =sign()=, which takes =n= as the input and returns the sign of it.
** Prototype
#+BEGIN_EXAMPLE
int sign(int n)
#+END_EXAMPLE           
** Program Design
The program consists of the function =sign(int n)= which returns the sign based on the number,
and =main()= which gets the input from =stdin=,calls the function =sign(n)= and prints the 
result on =stdout=.
** Algorithm
#+BEGIN_EXAMPLE
def sign(n):
   if n>0:
      return 1
   elif n==0:
      return 0
   return -1
roots=(-b+d)/2a,(-b-d)/2a
#+END_EXAMPLE
** Source Code
#+BEGIN_SRC C :cmdline <quad.in
  #include<stdio.h>
  #include<math.h>
  int sign(int n){
    if (n>0){
      return 1;
    }
    else if(n==0){
      return 0;
    }
    else{
      return -1;
    }
  }
  int main(){
    int a,b,c,m,det;
    float r1,r2;
    while(scanf("%d%d%d",&a,&b,&c)!=EOF){
      det=(b*b)-(4*a*c);
      m=sign(det);
      if (m==1){
	r1=(-b+sqrt(det))/(2*a);
	r2=(-b-sqrt(det))/(2*a);
	printf("%f %f",r1,r2);
      }
      else if(m==0){
	r1=-b/(2*a);
	printf("%f",r1);
      }
      else{
	printf("imaginary roots");
      }
    }
  }
#+END_SRC
** Test Input
#+BEGIN_EXAMPLE
1 -2 1
1 -3 2
1 1 1
#+END_EXAMPLE
** Output
#+RESULTS:
|1.000000|
|2.000000| |1.000000|
|imaginary roots|
* Distance between 2 points
*Program Description:* Write a program to compute the distance between two points. To read 
a point, the program should read 2 numbers from the user for the =x= and =y= coordinates.  
Hence your program should read numbers for the two points. Print the output on the stdout. 
Implement a function =distance(x1, y1, x2, y2)= that takes two points =(x1, y1)= and =(x2, y2)= 
as 4 parameters and returns the distance between the two points. Avoid duplicate calculations 
wherever possible.
** Specification
A function =distance()= which takes the coordinates of 2 points as inputsin int and returns the 
distance between them.
** Prototype
#+BEGIN_EXAMPLE
float distance(int x1,int y1,int x2,int y2)
#+END_EXAMPLE
** Program Design
The program consists of the functions =distance(int x1,int y1,int x2,int y2)= which returns the 
distance between the points (x1,y1) and (x2,y2) and =main()= which gets the inputs from =stdin=,
calls the function and prints the result on =stdout=.
** Algorithm
#+BEGIN_EXAMPLE
def distance(x1,y1,x2,y2):
   d=sqrt(pow(x1-x2,2)+pow(y1-y2,2))
   return d
#+END_EXAMPLE
** Source Code
#+BEGIN_SRC C :cmdline <dist.in
  #include<stdio.h>
  #include<math.h>
  float distance(int x1,int y1 ,int x2,int y2){
    float d;
    d=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
    return d;
  }
  int main(){
    int x1,x2,y1,y2;
    float d;
    scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
    d=distance(x1,y1,x2,y2);
    printf("%f",d);
  }
#+END_SRC
** Test Input
#+BEGIN_EXAMPLE
5 6
1 2
#+END_EXAMPLE
** Output
#+RESULTS:
|5.656854|
* Swap two variables.
*Program Description:*   Initialize two variables with values read from the user and exchange 
(swap) their contents. Print them before and after the swap.
** Specification
A function which swaps the 2 numbers.
** Program Design
The program consists of =main()= which gets the input from =stdin=, swaps them and prints them 
on =stdout=.     
** Algorithm
#+BEGIN_EXAMPLE
t=a
a=b
b=t
#+END_EXAMPLE
** Source Code
#+BEGIN_SRC C :cmdline <swap.in
  #include <stdio.h>
  int main (){
    int a,b,t;
    scanf ("%d%d", &a, &b);
    t = a;
    a = b;
    b = t;
    printf ("%d %d\n", a, b);  
    return 0;
  }
#+END_SRC
** Test Input
#+BEGIN_EXAMPLE
5 10
#+END_EXAMPLE
** Output
#+RESULTS:
: 10 5
* Swap using function
*Problem Description:*Define a function =swap()= to exchange the contents of the two variables, 
and check whether the function works as intended. If it does not work, what is the reason?
** Specification
A function =swap()= takes two numbers as inputs and returns the numbers after swapping them.
** Prototype
#+BEGIN_EXAMPLE
int swap(int* a, int* b)
#+END_EXAMPLE
** Program Description
The program contains a function =swap(int* a, int* b)=, which swaps the numbers and =main()=
which gets the input from =stdin=, calls the function and prints the output on =stdout=
** Algorithm
#+BEGIN_EXAMPLE
def swap(a, b):
   a,b=b,a
#+END_EXAMPLE
** Source Code
#+BEGIN_SRC C :cmdline <swap.in
  #include<stdio.h>
  void swap(int* a,int* b){
    int t=*a;
    *a=*b;
    *b=t;
  }
  int main(){
    int a,b;
    scanf("%d%d",&a,&b);
    swap(&a,&b);
    printf("%d %d\n",a,b);
  }
#+END_SRC
** Test Input
#+BEGIN_EXAMPLE
5 10
#+END_EXAMPLE
** Output
#+RESULTS:
: 10 5
* Circulate numbers
*Program Description:* Read four numbers =a, b, c, d= from stdin. Circulate them so that a 
gets the value of b, and so on: =a <- b <- c <- d <- a=
** Specification
A function that circulates the numbers.
** Program Design
 The program consists of  =main()= which gets the input from =stdin=, circulates them in the 
way =a <- b <- c <- d <- a= and prints the numbers on =stdout=.
** Algorithm
#+BEGIN_EXAMPLE
t=a1;
a1=a2;
a2=a3;
.
.
.
a_(n-1)=a_n;
a_n=t;
#+END_EXAMPLE
** Source Code
#+BEGIN_SRC C :cmdline <circle.in
  #include <stdio.h>
  int main (){
    int a, b, c, d,t;
    scanf ("%d%d%d%d", &a, &b, &c, &d);
    t = a;
    a = b;
    b = c;
    c = d;
    d = t;
    printf ("%d %d %d %d\n", a, b, c, d);
    return 0;
  }     
#+END_SRC
** Test Input
#+BEGIN_EXAMPLE
1 -3 2 6
#+END_EXAMPLE
** Output
#+RESULTS:
: -3 2 6 1

* Rearrange three numbers 
*Program Description:* Read three numbers =a, b, c= from stdin. Write a program to rearrange 
them so that =a $\le$ b $\le$ c=.
** Specification
2 functions =min2()=, which takes two integers as input  and returns the minimum of the two
and =min3()=, which takes three integers as inputs and returns the minimum of the three.
** Prototype
#+BEGIN_EXAMPLE
int min2(int a,int b)
int min3(int a,int b,int c)
#+END_EXAMPLE 
** Program Design
The program consists of the functions =min2(a,b)= which returns minimum of two numbers, =min3(a,b,c)=
which returns minimum of three numbers and =main()= which gets inputs from =stdin=, calls the 
function and prints the result on =stdout=.
** Algorithm
#+BEGIN_EXAMPLE
def min2(a,b):
   if a<=b:
      return a
   return b
def min3(a,b,c):
   t=min2(a,b)
   return min2(t,c)
#+END_EXAMPLE
** Source Code
#+BEGIN_SRC C :cmdline <rearr.in
  #include<stdio.h>
  int min2(int a,int b){
    if(a<=b){
      return a;
    }
    return b;
  }
  int min3(int a, int b, int c){
    int temp=min2(a,b);
    return min2(temp,c);
  }
  int main(){
    int a,b,c,s,p;
    scanf("%d%d%d",&a,&b,&c);
    p=a+b;
    s=a+b+c;
    a=min3(a,b,c);
    b=p-a;
    c=s-(a+b);
    printf("%d %d %d",a,b,c);
  }
#+END_SRC
** Test Input
#+BEGIN_EXAMPLE
1 -3 2
#+END_EXAMPLE
** Output
#+RESULTS:
: -3 1 2

* Rearrange numbers in an array
*Program Description:* Fill an array of 3 numbers with numbers read from stdin. Write a 
program to rearrange them so that =a[0] $\le$ a[1] $\le$ a[2]=
** Specification
2 functions =min2()=, which takes two integers as input  and returns the minimum of the two
and =min3()=, which takes three integers as inputs and returns the minimum of the three.
** Prototype
#+BEGIN_EXAMPLE
int min2(int a,int b)
int min3(int a,int b,int c)
#+END_EXAMPLE 
** Program Design
The program consists of the functions =min2(a,b)= which returns minimum of two numbers, =min3(a,b,c)=
which returns minimum of three numbers and =main()= which gets inputs from =stdin=, calls the 
function and prints the result on =stdout=.
** Algorithm
#+BEGIN_EXAMPLE
def min2(a,b):
   if a<=b:
      return a
   return b
def min3(a,b,c):
   t=min2(a,b)
   return min2(t,c)
#+END_EXAMPLE
** Source Code
#+BEGIN_SRC C :cmdline <rearrarr.in
#include<stdio.h>
int swap(int* a,int* b){
   int t=*a;
   *a=*b;
   *b=t;
}
int main(){
   int a[5],s=0,p;
   for(int i=0;i<3;i++){
      scanf("%d",&a[i]);
      s+=a[i];
   }
   if(a[0]>a[1]){
     swap(&a[0],&a[1]);
   }
   if(a[1]>a[2]){
     swap(&a[1],&a[2]);
   }
   if(a[0]>a[1]){
     swap(&a[0],&a[1]);
   }
   for(int i=0;i<3;i++){
      printf("%d ",a[i]);
   }
}
#+END_SRC
** Test Input
#+BEGIN_EXAMPLE
23 52 13
#+END_EXAMPLE
** Output
#+RESULTS:
: 13 23 52
     
*Ex03*
*Ex03*
* 24 hour format
Write a program to get a time in 24 hour format and convert it to a 12 hour format
** Program Design
The program consists of =main()=, which gets the input of time from =stdin=, 
converts it to 12 hour format and prints the result on =stdout=.
** Algorithm 
def func(h,m,s):
  if h<=12:
    if h==12:
      print("%d:%d:%d pm\n",h,m,s)
    else
      print("%d:%d:%d am\n",h,m,s)
  else
    if h==24:
      print("%d:%d:%d am\n",h-24,m,s)
    else
      print("%d:%d:%d pm\n",h-12,m,s)

** Source Code:

#+BEGIN_SRC C :cmdline <24time.in
  #include<stdio.h>
  int main(){
    int h,m,s;
    scanf("%d%d%d",&h,&m,&s);
    if(h<=12){
      if(h==12{
        printf("%d:%d:%d pm\n",h,m,s);
      }
      else{
        printf("%d:%d:%d am\n",h,m,s);
      }
    }
    else{
      if(h==24){
        printf("%d:%d:%d am\n",h-24,m,s);
      }
      else{
        printf("%d:%d:%d pm\n",h-12,m,s);
      }    
    }
    
  }    
#+END_SRC

** Test Input:
#+BEGIN_EXAMPLE
15 34 23
#+END_EXAMPLE
** Output:
#+RESULTS:
: 3:34:23 pm

* Time Comparison
Write a function to accept 2 time in hours minutes and seconds and compare which time 
is earlier.
** Program Design
The program consists of =main()=, which gets the input from =stdin=, compares the
times and prints the result on =stdout=.
** Algorithm

#+BEGIN_EXAMPLE
def func(h1,m1,s1,h2,m2,s2):
  if h1>h2:
    print("t1 is earlier")
  elif h1<h2:
    print("t2 is earlier")
  else
    if m1>m2:
      print("t1 is earlier")
    elif m1<m2:
      print("t2 is earlier")
    else:
      if s1>s2:
        print("t1 is earlier")
      elif s1<s2:
        print("t2 is earlier")
      else:
        print("Both are same")
#+END_EXAMPLE
** Source Code:
#+BEGIN_SRC C :cmdline <timecmp.in
  #include<stdio.h>
  int main()
  {
    int h1,m1,s1,h2,m2,s2;
    scanf("%d%d%d",&h1,&m1,&s1);
    scanf("%d%d%d",&h2,&m2,&s2);
    printf("%d %d %d\t%d %d %d\n",h1,m1,s1,h2,m2,s2);
    if(h1<h2){
      printf("t1 is earlier");
    }
    else if(h1>h2){
      printf("t2 is earlier");
    }
    else{
      if(m1>m2){
        printf("t2 is earlier");
      }
      else if(m1<m2){
        printf("t1 is earlier");
      }
      else{
        if(s1>s2){
          printf("t2 is earlier");
        }
        else if(s1<s2){
          printf("t1 is gtreater");
        }
        else{
          printf("both are equal");
        }
      }     
    }
  }
  
  
#+END_SRC

** Test Input:
#+BEGIN_EXAMPLE
16 23 45  13 23 43
#+END_EXAMPLE
** Output:
#+RESULTS:
: t2 is earlier            

* Time difference
Write a program to calculate the time difference between the two 
time the user enters and print it
** Specification
A function =sign()=, which takes an integer as the input and returns
it's sign to the calling function.
** Prototype
#+BEGIN_EXAMPLE
int sign(int a);
#+END_EXAMPLE
** Program Design
The program consists a function =sign(int a)=, which returns the 
sign of the integer, and =main()=, which gets the input from =stdin=,
calls the function and prints the rsult accordingly on =stdout=.
** Algorithm
#+BEGIN_EXAMPLE
def sign(a):
  if a>=0:
    return 1
  else
    return -1

#+END_EXAMPLE
** Sorce Code

#+BEGIN_SRC C :cmdline <timediff.in
  #include<stdio.h>
  
  int sign(int a){
    if(a>=0){
      return 1;
    }
    else{
      return -1;
    }
  }
  
  int main(){
    int a,b,c,d,e,f,g,h,i;
    scanf("%d%d%d",&a,&b,&c);
    scanf("%d%d%d",&d,&e,&f);
    g=sign(a-d);
    h=sign(b-e);
    i=sign(c-f);
    if(g>0){
      if(h>0 && i>0){
        printf("%d:%d:%d\n",a-d,b-e,c-f);
      }
      else if(h>0 && i<0){
        printf("%d:%d:%d\n",a-d,b-e,f-c);
      }
      else if(h<0 && i>0){
        printf("%d:%d:%d\n",a-d,e-b,c-f);
      }
      else{
        printf("%d:%d:%d\n",a-d,e-b,f-c);
      }  
    }
    else{
      if(h>0 && i>0){
        printf("%d:%d:%d\n",d-a,b-e,c-f);
      }
      else if(h>0 && i<0){
        printf("%d:%d:%d\n",d-a,b-e,f-c);
      }
      else if(h<0 && i>0){
        printf("%d:%d:%d\n",d-a,e-b,c-f);
      }
      else{
        printf("%d:%d:%d\n",d-a,e-b,f-c);
      }  
    }
  }
  
#+END_SRC

** Test Input
#+BEGIN_EXAMPLE
18 16 24        13 15 23
#+END_EXAMPLE
** Output
#+RESULTS:  
: 5 1 1                 

* Smallest and largest of 4 numbers
Write a program to find the smallest and largest number out of the 4 numbers entered 
from the standard input
** Specification
2 functions =min2()= and =max2()=, which take 2 integers as the input and returns
the minimum and maximum of the two to the calling function respectively.
** Prototype
#+BEGIN_EXAMPLE
int min2(int a, int b);
int max2(int a, int b);
#+END_EXAMPLE
** Program Design
The program consists of 2 functions =min2(int a, int b)= and =max2(int a, int b)=
which returns the minimum and maximum of the 2 numbers, and =main()=, which
gets the input from =stdin=, calls the functions, and prints the result on =stdout=.
** Algorithm
#+BEGIN_EXAMPLE
def min2(a,b):
  if a>b:
    return b
  else:
    return a
def max2(a,b):
  if a<b:
    return b
  else:
    return a
#+END_EXAMPLE
** Source Code

#+BEGIN_SRC C :cmdline <smalllarge.in
  #include<stdio.h>
  int min2(int a, int b){
    if(a>b){
      return b;
    }
    else{
      return a;
    }
  }

  int max2(int a, int b){
    if(a<b){
      return b;
    }
    else{
      return a;
    }
  }

  int main(){
    int a,b,c,d,m,n;
    scanf("%d%d%d%d",&a, &b, &c, &d);
    m=min2(a,b);
    m=min2(m,c);
    m=min2(m,d);
    n=max2(a,b);
    n=max2(n,c);
    n=max2(n,d);
    printf("%d,%d\n",m,n);
  }

#+END_SRC

** Test Input
#+BEGIN_EXAMPLE
23 43 65 12
#+END_EXAMPLE
** Output
#+RESULTS:
: 12 65

* Grades
Write a function =grades()= to translate the marks of a student in various subjects 
into letter grades and print the grades on the output.
| Mark range | Grade points | Leter grade |
|     91-100 |           10 | S           |
|      81-90 |            9 | A           |
|      71-80 |            8 | B           |
|      61-70 |            7 | C           |
|      57-60 |            6 | D           |
|      51-56 |            5 | E           |
|        <50 |            0 | U           |
** Specification
A function =grade()=, which gets the mark as the input and returns a grade as 
character to the calling function.
** Prototype
#+BEGIN_EXAMPLE
char grade(int x);
#+END_EXAMPLE
** Program Design
The program consists of a function =grade(int x)=, which returns a grade as a 
character based on the mark, and =main()=, which gets the input from =stdin=,
calls the function and prints the result on =stdout=.
** Algorithm
#+BEGIN_EXAMPLE
def grade(x):
  if x>90:
    return 's'
  elif x>80:
    return 'a'
  elif x>70:
    return 'b'
  elif x>60:
    return 'c'
  elif x>56:
    return 'd'
  elif x>50:
    return 'e'
  else:
    return 'u'
#+END_EXAMPLE  
** Source Code

#+BEGIN_SRC C :cmdline <grade.in
  #include<stdio.h>
  char grade(int x){
    if(x>90){
      return 's';
    }
    else if(x>80){
      return 'a';
    }
    else if(x>70){
      return 'b';
    }
    else if(x>60){
      return 'c';
    }
    else if(x>56){
      return 'd';
    }
    else if(x>50){
      return 'e';
    }
    else{
      return 'u';
    }
  }  
  int main(){
    int a[20],n;
    char g;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
      scanf("%d",&a[i]);
    }
    for(int i=0;i<n;i++){
      g=grade(a[i]);
      printf("%c\n",g);
    }
  }


#+END_SRC

** Test Input
#+BEGIN_EXAMPLE
8
100 98 78 45 98 78 40 90
#+END_EXAMPLE
** Output
#+RESULTS:
:  s 
:  s 
:  b 
:  u 
:  s 
:  b
:  u 
:  a 

* Tariff Calculator
Write a function =eb()= to find out the domestic eb bill based on the given slab rates
1. Consumption upto 100 units: free.
2. Consumption above 100 units and upto 200 units: Rs 1.50 per unit.
3. Consumption above 200 units and upto 500 units: Rs 2.00 per unit 
   for 101-200 units and Rs 3.00 per unit for 201-500 units.
4. Consumption above 500 units: Rs 3.50 per unit for 101-200 units, 
   Rs 4.60 per unit for 201-500 units, and Rs 6.60 beyond 500 units.
** Specification
A function =eb()=, which takes the number of units as the input and returns the cost
based on the conditions to the calling function.
** Prototype
#+BEGIN_EXAMPLE
float eb(int unit);
#+END_EXAMPLE
** Program Design
The program consists of a function =eb(int unit)=, which returns the net cost, and =main()=,
which gets the input from =stdin=, calls the function and prints the result on =stdout=.
** Algorithm
#+BEGIN_EXAMPLE
def eb(u):
  if u<=100:
    return 0
  elif u>100 and u<=200:
    return 1.5*u
  elif u>200 and u<=500:
    return (u-200)*3.0+(u-100)*2.0
  else:
    return (u-500)*6.6+(u-200)*4.6+(u-100)*3.5
#+END_EXAMPLE
** Source Code

#+BEGIN_SRC C :cmdline <eb.in

  #include<stdio.h>
  float eb(int unit){
    if(unit<=100){
      return 0.0;
    }
    else if((unit>100)&&(unit<=200)){
      return 1.5*unit;
    }
    else if((unit>200)&&(unit<=500)){
      return(unit-200)*3.0+100*2.0;
    }
    else{
      return (unit-500)*6.6+300*4.6+100*3.5;
    }
  }
  int main(){
    int unit;
    float cost;
    scanf("%d",&unit);
    cost=eb(unit);
    printf("%.4f\n",cost);
  }

#+END_SRC

** Test Input
#+BEGIN_EXAMPLE    
700 
#+END_EXAMPLE
** Output
#+RESULTS:
: 3050.0000  

* Income Tax
Write a function =tax()= to calculate the income tax based on the age and the income 
of the person
1. Income Tax Slab for Individual Tax Payers (Less Than 60 Years Old)
| Income Slab                | Tax Rate |
| Up to Rs.2,50,000          |   No tax |
| Rs.2,50,000 - Rs.5,00,000  |       5% |
| Rs.5,00,000 - Rs.10,00,000 |      20% |
| Rs.10,00,000 and beyond    |      30% |
2. Income Tax Slab for Senior Citizens (60 Years Old Or more but Less than 80 Years Old)
| Income Slab                | Tax Rate |
| Up to Rs.3,00,000          |   No tax |
| Rs.3,00,000 - Rs.5,00,000  |       5% |
| Rs.5,00,000 - Rs.10,00,000 |      20% |
| Rs.10,00,000 and beyond    |      30% |
3. Income Tax Slab for Senior Citizens (More than 80 years old)
| Income Slab                | Tax Rate |
| Up to Rs.2,50,000          | No tax   |
| Rs.2,50,000 - Rs.5,00,000  | No tax   |
| Rs.5,00,000 - Rs.10,00,000 | 20%      |
| Rs.10,00,000 and beyond    | 30%      |
Modify your function to take the age and the income as the parameters and calculate the tax.
** Specification
A function =tax()=, which gets the age and income as the inputs, checks the conditions
and returns the value of tax to the calling function
** Prototype
#+BEGIN_EXAMPLE
float tax(int age, int income);
#+END_EXAMPLE
** Program Design
The program consists of a function =tax(int age, int income)=, which returns the value
of tax based on conditions, and =main()=, which gets the input from =stdin=, calls
the function and prints the result on =stdout=.
** Algorithm
#+BEGIN_EXAMPLE
def tax(age,income):
  if(age<60):
      if income<250000:
        return 0.0
      elif income>=250000 and income<500000:
        return (5.0/100)*income
      elif income>=500000 andincome<1000000:
        return (20.0/100)*income
      else:
        return (30.0/100)*income
    else ifage>=60 and age<80:
      if income<300000;
        return 0.0
      elif income>=300000 and income<500000:
        return (5.0/100)*income
      elif income>=500000 and income<1000000:
        return (20.0/100)*income
      else:
        return (30.0/100)*income
    else:
      if income<500000:
        return 0.0
      elif income>=500000 and income<1000000:
        return (20.0/100)*income
      else:
        return(30.0/100)*income
#+END_EXAMPLE
** Source Code
     
#+BEGIN_SRC C :cmdline <tax.in
  #include<stdio.h>
  float tax(int age, int income){
    if(age<60){
      if(income<250000){
        return 0.0;
      }
      else if((income>=250000)&&(income<500000)){
        return (5.0/100)*income;
      }
      else if((income>=500000)&&(income<1000000)){
        return (20.0/100)*income;
      }
      else{
        return (30.0/100)*income;
      }
    }
    else if((age>=60)&&(age<80)){
      if(income<300000){
        return 0.0;
      }
      else if((income>=300000)&&(income<500000)){
        return (5.0/100)*income;
      }
      else if((income>=500000)&&(income<1000000)){
        return (20.0/100)*income;
      }
      else{
        return (30.0/100)*income;
      }
    }
    else{
      if(income<500000){
        return 0.0;
      }
      else if((income>=500000)&&(income<1000000)){
        return (20.0/100)*income;
      } 
      else{
        return(30.0/100)*income;
      }
    }
  }
  int main()
  {
    int age,income;
    float t;
    scanf("%d%d",&age,&income);
    t=tax(age,income);
    printf("%f\n",tax);
  }

#+END_SRC

** Test Input
#+BEGIN_EXAMPLE
85 3000000
#+END_EXAMPLE
** Output
#+RESULTS:
: 900000.0           





                

* Inversion
In a sequence of integers =a0, a1, a2, a3=, any pair of integers =(ai, aj)= 
is said to be an /inversion/ if =ai > aj= for =i < j=. Write a program to 
correct/order all the inversions in the	sequence. 
** Specification
A function =inversion()=, which takes an array and it's length as input,
counts the number of inversions to be performed and returns the result
to the calling function.
** Prototype
#+BEGIN_EXAMPLE
int inversion(int a[], int n);
#+END_EXAMPLE
** Program Design
The program consists of a function =inversion(int a[], int n)=, which
counts the number of inversions to be done, and =main()=, which gets 
the input from =stdin=, calls the function, and prints the result
on =stdout=.
** Algorithm
#+BEGIN_EXAMPLE
def inversion(a,n):
  c=0
  for i in range(n):
    for j in range(i+1,n):
      if a[i]>a[j]:
        c+=1
  return c
#+END_EXAMPLE
** Source Code
#+BEGIN_SRC C :cmdline <inversion.in
  #include<stdio.h>
  int inversion(int a[], int n){
    int c=0;
    for(int i=0;i<n;i++){
      for(int j=i+1;j<n;j++){
        if(a[i]>a[j]){
          c++;
        }
      }
    }
    return c;
  }
  int main(){
    int a[20],n;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
      scanf("%d",&a[i]);
    }
    int c=inversion(a,n);
    printf("%d",c);
  }
#+END_SRC
** Test Input
#+BEGIN_EXAMPLE
5
1 20 6 4 5
#+END_EXAMPLE
** Output
#+RESULTS:
: 5
*Ex04*
* Indent  
   Define a function =indent(n)= to print $n$ times the pattern
   (=|--=) in a line. =n=, the number of times is given as a
   parameter. Construct an input file in which each line is formated
   as a pair of numbers referred to as =level= and =key=. For each
   line 
   #+BEGIN_EXAMPLE
   level key 
   #+END_EXAMPLE
   print =level= number of times the pattern =|--= followed by the
   =key=. \hfill (/count/).
   #+BEGIN_EXPORT latex
   \linespread{1}
   #+END_EXPORT
   #+BEGIN_EXAMPLE
   0 5
   1 10
   1 15
   2 20
   2 25
   2 30
   2 35
   3 40
   3 45
   3 50
   3 55
   #+END_EXAMPLE
   #+BEGIN_EXPORT latex
   \linespread{1.2}
   #+END_EXPORT
   When the lines in the file are read and printed, the display will
   be as shown below.
   #+BEGIN_EXPORT latex
   \linespread{1}
   #+END_EXPORT
   #+BEGIN_EXAMPLE
   5
   |--10
   |--15
   |--|--20
   |--|--25
   |--|--30
   |--|--35
   |--|--|--40
   |--|--|--45
   |--|--|--50
   |--|--|--55
   #+END_EXAMPLE
   #+BEGIN_EXPORT latex
   \linespread{1.2}
   #+END_EXPORT
   # Test the function by printing 10 lines of stars for n = 0, 1, 2, \ldots 10.
   # 2. Define a function =power (base, exponent)= to compute x^n. \hfill
   (/count/)
** Specification
   A function =indent()=, which takes an array =a[]=, number of lines =n= as input
   and prints the =level= and =key= based on the array on the =stdout=.
** Prototype
   #+BEGIN_EXAMPLE
   void indent(int a[], int n)
   #+END_EXAMPLE
** Program Design
   The program consists of a function =indent(int a[], int n)=, which prints the
   =level= and =key= on the =stdout=, and =main()=, which reads the input from
   =stdin= and calss the function.
** Algorithm
   #+BEGIN_EXAMPLE
   def indent(a,n):
      for i in range(n):
         for j in range(a[i]):
            print("|--")
         print("%d\n",5*(i+1))
   #+END_EXAMPLE
** Source Code
   #+BEGIN_SRC C :cmdline <indent.in
   #include<stdio.h>
   void indent(int a[], int n){
      for(int i=0;i<n;i++){
        for(int j=0;j<a[i];j++){
           printf("|--");
        }
      printf("%d\n",5*(i+1));
      }
   }
   int main(){
      int n,a[100];
      scanf("%d",&n);
      for(int i=0;i<n;i++){
        scanf("%d",&a[i]);
      }
      indent(a,n);
   }
   #+END_SRC
** Test Input
   #+BEGIN_EXAMPLE
   11
   0 1 1 2 2 2 2 3 3 3 3
   #+END_EXAMPLE
** Output
   #+RESULTS:
   5
   |--10
   |--15
   |--|--20
   |--|--25
   |--|--30
   |--|--35
   |--|--|--40
   |--|--|--45
   |--|--|--50
   |--|--|--55

* Array Length
   Represent a list of numbers by an array of numbers terminated by -1
   as the end of list marker. Define a function =int array_len(int
   a[])= that takes such an array as the parameter and returns the
   length of the array, that is, the number of items in the array
   \hfill (/sentinel/)
** Specification
   A function =array_len()=, which takes an array =a[]= as the input,
   counts the number of elements in the array and returns it to the
   calling function.
** Prototype
   #+BEGIN_EXAMPLE
   int array_len(int a[])
   #+END_EXAMPLE
** Program Design
   The program consists of a function =array_len(int a[])=, which 
   counts the number of elements in the array, and =main()=, which
   gets the input from =stdin=, calls the function, and prints
   the result on =stdout=.
** Algorithm
   #+BEGIN_EXAMPLE
   def array_len(a):
      i=0
      while a[i]!=-1:
         i++
      return i
   #+END_EXAMPLE
** Source Code
   #+BEGIN_SRC C :cmdline <arraylen.in
   #include<stdio.h>
   int array_len(int a[]){
      int i=0;
      while(a[i]!=-1){
         i++;
      }
      return i;
   }
   int main(){
      int a[100],i=0,m;
      while(1){
        scanf("%d",&a[i]);
        if(a[i]==-1){
          break;
        }
        i++;
      }
      m=array_len(a);
      printf("%d\n",m);
   }
   #+END_SRC
** Test Input
   #+BEGIN_EXAMPLE
   2 4 6 13 12 11 17 19 21 -1
   #+END_EXAMPLE
** Output
   #+RESULTS:
   | 9 |
* Sub Array
   Print a subarray. Write a function =print_array(a, low, high)= that
   prints the subarray =a[low:high]=, that is, the items of array =a=
   from =low= to =high=. =low= and =high= are called the /lower bound/
   and /upper bound/ of the subarray. We follow the convention of
   upper bound excluded. That is, \hfill (/visitor/)
   #+BEGIN_EXAMPLE
   a[l:h] = a[l], a[l+1], ..., a[h-1]
   #+END_EXAMPLE
   Note that =a[h]= is not a part of =a[l:h]=.
** Specification
   A function =sub_array()=, which takes an array =a[]=, lower limit =l=,
   upper limit =h= as inputs and prints array =a[l:h]= on =stdout=.
** Prototype
   #+BEGIN_EXAMPLE
   void sub_array(int a[], int l, int h)
   #+END_EXAMPLE
** Program Design
   The program consists of a function =sub_array(int a[], int l, int h)=,
   which prints the sub array from =l= to =h=, and =main()=, which reads
   the input from =stdin=, and calls the function.
** Algorithm
   #+BEGIN_EXAMPLE
   def sub_array(a,l,h):
      for i in range(l,h):
         print(a[i])
   #+END_EXAMPLE
** Source Code
   #+BEGIN_SRC C :cmdline <subarr.in
   #include<stdio.h>
   void sub_array(int a[], int l, int h){
      for(int i=l;i<h;i++){
         printf("%d%s",a[i],i==h-1?"":",");
      }
   }
   int main(){
      int a[100],n,l,h;
      scanf("%d",&n);
      for(int i=0;i<n;i++){
         scanf("%d",&a[i]);
      }
      scanf("%d%d",&l,&h);
      sub_array(a,l,h);
   }
   #+END_SRC
** Test Input
   #+BEGIN_EXAMPLE
   10
   3 9 7 1 0 5 6 8 2 4
   3 7
   #+END_EXAMPLE
** Output
   #+RESULTS:
 | 1,0,5,6 | 
* Sum, mean, variance
   1. Define a function =sum(array, low, high)= that computes the sum
      of the numbers of the subarray =array[low:high]=. Using this
      function, define a function =mean(array, low, high)= to compute
      the mean of the numbers in the subarray =array[low:high]=.
   2. Write a function =variance(array, low, high)= to compute the
      variance of the numbers of the subarray =array[low:high]=. Let
      =variance()= use =mean()=. Test the functions =mean()= and
      =variance()= from =main()= which should read a list of numbers
      from a file and print the mean and variance. Test it for several
      lists of numbers. \hfill (/accumulator, map/)
   3. Write a function to find the number of items above the mean.
** Specification
   4 functions =sum()=, which finds the sum of =a[l:h]=, =mean()=, which
   finds the mean, =variance()=, which finds the variance, and =count()=
   which finds number of people above the mean.
** Prototype
   #+BEGIN_EXAMPLE
   int sum(int a[], int l, int h)
   float mean(int a[], int l, int h)
   float variance(int a[], int l, int h)
   int count(int a[], int l, int h)
   #+END_EXAMPLE
** Program Design
   The program consists of 4 functions =sum(int a[], int l, int h)=, which
   finds sum and returns it, =mean(int a[], int l, int h)=, which finds mean
   and returns it, =variance(int a[], int l, int h)= which finds variance and 
   returns it, =count(int a[], int l, int h)=, which finds number of people 
   above the mean and returns it and =main()=, which gets input from =stdin=,
   calls the functions and prints the result on =stdout=.
** Algorithm
   #+BEGIN_EXAMPLE
   def sum(a,l,h):
      s=0
      for i in range(l,h):
         s+=a[i]
      return s
   def mean(a,l,h):
      return sum(a,l,h)/(1.0*(h-l))
   def variance(a,l,h):
      m=mean(a,l,h),s=0
      for i in range(l,h):
         s+=(a[i]-m)^2
      return s/(h-l)
   def count(a,l,h):
      m=mean(a,l,h)
      s=0
      for i in range(l,h):
         if a[i]>m:
            s++
      return s
   #+END_EXAMPLE
** Source Code
   #+BEGIN_SRC C :cmdline<smv.in
   #include<stdio.h>
   int sum(int a[], int l, int h){
      int s = 0;
      for(int i = l; i < h; i++){
         s += a[i];
      }
      return s;
   }
   float mean(int a[], int l, int h){
      return sum(a, l, h)/(1.0*(h - l));
   }
   float variance(int a[], int l, int h){
      float m = mean(a, l, h), s = 0;
      for(int i = l; i < h; i++) {
         s += ((a[i] - m)*(a[i] - m));
      }
      return s/(1.0*(h - l));
   }
   int count(int a[], int l, int h){
      float m = mean(a, l, h);
      int s = 0;
      for(int i = l; i < h; i++) {
         if(a[i] > m){
            s++;
         }
      }
      return s;
   }
   int main(){
      int a[5], l, h;
      for(int i = 0; i < 5; i++) {
         scanf("%d", &a[i]);
      }
      scanf("%d %d", &l, &h);
      printf("%d %f %f %d", sum(a, l, h), mean(a, l, h), variance(a, l, h), count(a, l, h));
      return 0;
   }
   #+END_SRC
** Test Input
   #+BEGIN_EXAMPLE
   72 144 53 69 78
   0 5
   #+END_EXAMPLE
** Output
   #+RESULTS:
   |416| |83.199997| |992.560059| |1|
* Prime number 
   Define a function =is_prime(n)= that tests whether
   a non-negative integer =n= is a prime number and returns =true= if
   =n= is prime and =false= if =n= is not prime. Test it for the first
   100 integers. \hfill (/search/)
** Specification
   A function =is_prime()=, which takes the number =a= as input, checks
   if a number is prime or not and returns the result.
** Prototype
   #+BEGIN_EXAMPLE
   int is_prime(int a)
   #+END_EXAMPLE
** Program Design
   The program consists of a function =is_prime(int a)=, which checks if
   a number is prime or not and =main()=, which gets the input from =stdin=,
   calls the function and prints the result on =stdout=.
** Algorithm
   #+BEGIN_EXAMPLE
   def is_prime(a):
      i=2,f=1
      while i<a/2:
         if a%i==0:
            f=0
            break
         i++
      return f
   #+END_EXAMPLE
** Source Code
   #+BEGIN_SRC C :cmdline <prime.in
   #include<stdio.h>
   int is_prime(int a){
      int i=2,f=1;
      while(i<a/2){
         if(a%i==0){
            f=0;
            break;
         }
         i++;
      }
      return f;
   }
   int main(){
      int n,f;
      scanf("%d",&n);
      f=is_prime(n);
      if(f==1){
         printf("Prime");
      }
      else{
         printf("Not prime");
      }
   }
   #+END_SRC
** Test Input
   #+BEGIN_EXAMPLE
   11
   14
   #+END_EXAMPLE
** Output
   #+RESULTS:
   |Prime|
   |Not prime|
* Linear search \hfill (/search/)
   1. Define a function =linear_search(a, n, target)=. It searches the
      subarray =a[0:n]= for the =target=. If the target is in the
      array, the function returns the index of the target. If the
      target is not in the array, the function should return an
      invalid index (an invalid index is one outside the range $0 \le
      index < n$). Test the function from =main()=. Let =main()= read
      the input from stdin. Write two versions of =linear_search()=,
      one using =break= and the other without using =break=.
   2. Implement a third version of =linear_search(array, n, target)=
      that uses the =target= as the sentinel at =a[n]=. Write the
      specification for the function.
** Specification
   3 functions =linear_search()=, =linear_search_n()=, =binary_search()=
   all which get an integer array, its length and target element as 
   input and returns an index as the output.
** Prototype
#+BEGIN_EXAMPLE
int linear_search(int a[], int n, int t)
int linear_search_n(int a[], int n, int t)
int binary_search(int a[], int n, int t)
#+END_EXAMPLE
** Program Design
   The program consists of 3 functions =linear_search(int a[], int n, int t)=,
   =linear_search_n(int a[], int n, int t)=, =binary_search(int a[], int n, int t)=
   which returns an index of whether an element exists in array to the caller,
   and =main()=, which gets the input from =stdin=, calls the function and 
   prints the outputon =stdout=.
** Algorithm
#+BEGIN_EXAMPLE
def linear_search(a,n,t):
   for i in range(n):
      if a[i]==t:
         break
   return i
def linear_search_n(a,n,t):
   i=0
   while i<n and a[i]!=t:
      i=i+1
   return i
def binary_search(a,n,t):
   l=0,u=n-1,f=0,m
   while l<=u and f=0:
      m=(l+u)/2
      if t==a[m]:
         f=m
      elif a[m]>t:
         u=m-1
      else:
         l=m+1
   if f==0:
      return -1
   return f   
#+END_EXAMPLE
** Source Code
   #+BEGIN_SRC C :cmdline <search.in
   #include<stdio.h>
   int linear_search(int a[], int n, int t){
      int i = 0;
      for(i = 0; i < n; i++) {
         if(a[i] == t){
            break;
         } 
      }
      return i;
   }
   int linear_search_n(int a[], int n, int t){
      int i = 0;
      while(i < n && a[i] != t){
         i++;
      } 
      return i;
   }
   int binary_search(int a[], int n, int t){
      int l = 0, u = n - 1, flag = 0, mid;
      while(l <= u && flag == 0) {
         mid = (l + u)/2;
         if(t == a[mid]){
            flag = mid;
         }
         else if(a[mid] > t) {
            u = mid - 1;
         }
         else{
            l = mid + 1;
         } 
      }
      if(flag == 0){ 
         return -1;
      }
      return flag;
   }
   int main(){
      int a[100], n, t;
      scanf("%d", &n);
      for(int i = 0; i < n; i++) {
         scanf("%d", &a[i]);
      }
      scanf("%d", &t);
      printf("%d %d %d", linear_search(a,n,t),linear_search_n(a,n,t),binary_search(a,n,t));
      return 0;
   }
   #+END_SRC
** Test Input
   #+BEGIN_EXAMPLE
   10
   10 12 15 25 29 37 69 78 87 100
   37
   #+END_EXAMPLE
** Output
   #+RESULTS:
   |5| |5| |5|
* Minimum
   We are given an array =a[0:n]= of =n= comparable
   items. Define a function =minimum(a, low, high)= that returns the
   index of the smallest item in the subarray =a[low:high]=. Test the
   function from =main()= for several lists of numbers. Each test
   should read a list of numbers from stdin. \hfill (/accumulator/)
** Specification
   A function =min()=, which takes the array =a[]=, lower bound =l=
   and upper bound =h= as inputs and returns the index of the smallest
   element.
** Prototype
   #+BEGIN_EXAMPLE
   int min(int a[], int l, int h)
   #+END_EXAMPLE
** Program Design
   The program consists of a function =min(int a[], int l, int h)=,
   which returns the index of the smallest element, and =main()=,
   which gets the input from =stdin=, calls the function and prints
   the output on =stdout=.
** Algorithm
   #+BEGIN_EXAMPLE
   def min(a,l,h):
      m=l
      for i in range(l+1,h):
         if a[i]<a[m]:
            m=i
      return m
   #+END_EXAMPLE
** Source Code
   #+BEGIN_SRC C :cmdline <min.in
   #include<stdio.h>
   int min(int a[], int l, int h){
      int m=l;
      for(int i=l+1;i<h;i++){
         if(a[i]<a[m]){
            m=i;
         }
      }
      return m;
   }
   int main(){
      int n,a[30],m,l,h;
      scanf("%d",&n);
      for(int i=0;i<n;i++){
         scanf("%d",&a[i]);
      }
      scanf("%d%d",&l,&h);
      m=min(a,l,h);
      printf("%d",m);
   }
   #+END_SRC
** Test Input
   #+BEGIN_EXAMPLE
   10
   0 9 1 8 2 7 3 6 4 5
   1 6
   #+END_EXAMPLE
** Output
   #+RESULTS:
  |2 |
* Armstrong number
   1. Define a function =int to_digits(n, s)= to convert an integer
      to a string of single digit numbers. For example, it converts
      371 to [3,7,1]. The function has two outputs:
      1. =s=, an array of single digit numbers, which is passed as a
         parameter, and
      2. the number of single digits, which is returned as a value.
      Test the function from =main()=.
   2. Define a function =cube(x)= that returns $x^3$. 
   3. Write a function =is_armstrong(n)= that tests whether the
      integer =n= is an Armstrong number. An Armstrong number is
      equal to the sum of cubes of its digits. Test the function to
      find out all the Armstrong numbers from 0 to 500.
** Specification
   3 functions =to_digits()=, which gets the number =n= and array =a[]=
   as input, stores each digit in the array and returns number of digits,
   =cube()=, which finds the cube of a number, and =is_armstrong()=, which
   gets the number, each individual digit and its length as input and checks
   if a number is armstrong or not.
** Prototype
   #+BEGIN_EXAMPLE
   int to_digits(int n, int s[])
   int cube(int n)
   int is_armstrong(int n, int s[], int b)
   #+END_EXAMPLE
** Program Design
   The program consists of 3 functions =to_digits(int n, int s[])= which finds
   number of digits and stores them in an array, =cube(int n)= which finds cube 
   of a number, =is_armstrong(int n, int s[], int b)= which checks if a number is
   armstrong or not, and =main()=, which gets the input from =stdin=, calls the
   functions and prints the result on =stdout=.
** Algorithm
   #+BEGIN_EXAMPLE
   def to_digits(n,s):
      i=0
      while n!=0:
         s[i]=n%10
         n/=10
         i+=1
      return i
   def cube(n):
      return n*n*n
   def is_armstrong(n,s,b):
      a=0
      for i in range(b):
         a+=cube(s[i])
      if n==a:
         return 1
      return 0
   #+END_EXAMPLE
** Source Code
   #+BEGIN_SRC C :cmdline <armstrong.in
   #include<stdio.h>
   int to_digits(int n, int s[]){
      int i=0;
      while(n!=0){
         s[i]=n%10;
         n/=10;
         i++;
      }
      return i;
   }
   int cube(int n){
      return n*n*n;
   }
   int is_armstrong(int n, int s[], int b){
      int a=0;
      for(int i=0;i<b;i++){
         a+=cube(s[i]);
      }
      if(n==a){
        return 1;
      }
      return 0;
   }
   int main(){
      int n,s[30],f,a;
      scanf("%d",&n);
      a=to_digits(n,s);
      f=is_armstrong(n,s,a);
      if(f==1){
         printf("Armstrong");
      }
      else{
        printf("Not Armstrong");
      }
   }
   #+END_SRC
** Test Input
   #+BEGIN_EXAMPLE
   153
   372
   #+END_EXAMPLE
** Output
   #+RESULTS:
   |Armstrong|
   |Not Armstrong|
*Ex05*
* Polynomial evaluation
   A polynomial $a_{n-1}x^{n-1} +
   a_{n-2}x^{n-2} + \ldots + a_{1}x + a_{0}$ is represented by an array
   =a[0:n]= of its coefficients. Write a program to compute the value
   of a polynomial using Horner's rule. The crux of the algorithm is:
   \hfill (/accumulator/)
   *Algorithm development*
   #+LATEX: \linespread{1}
   #+BEGIN_EXAMPLE
   s = 0
   for i = n-1 down to 0:
     s = s * x + a[i]
   #+END_EXAMPLE
   #+LATEX: \linespread{1.2}
   Compare the algorithm with the algorithm for summing the items of
   an array.
** Specification
   A function =polynomial()= which takes an array =a[]=, it's length
   =n= and =x= as inputs and returns the sum to the calling function.
   ** Prototype
   #+BEGIN_EXAMPLE
   int polynomial(int a[], int x, int n)
   #+END_EXAMPLE
** Prototype
#+BEGIN_EXAMPLE
int polynomial(int a[], int x, int n) 
#+END_EXAMPLE
** Program Design
   The program has function =polynomial(int a[], int x, int n)= which
   finds the sum and returns it, and =main()=, which reads the input
   from =stdin= , calls the function and prints the output on =stdout=.
** Algorithm
#+BEGIN_EXAMPLE
def polynomial(a[],x,n):
   s=0
   for i in range(n-1,0,-1):
      s=s*x+a[i]
   return s
#+END_EXAMPLE
** Source Code
#+BEGIN_SRC C :cmdline <poly.in
  #include<stdio.h>
  int polynomial(int a[], int x, int n){
    int s=0;
    for(int i=n-1;i>=0;i--){
      s=s*x+a[i];
    }
    return s;
  }
  int main(){
    int a[20],n,x;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
      scanf("%d",&a[i]);
    }
    scanf("%d",&x);
    int m=polynomial(a,x,n);
    printf("%d\n",m);
  }
#+END_SRC
** Test Input
#+BEGIN_EXAMPLE
4
1 2 5 1
3
#+END_EXAMPLE
** Output
#+RESULTS:
: 79
* Binary search
   We are given a sorted array of numbers. Define a function
   #+LATEX: \linespread{1}
   #+BEGIN_EXAMPLE
   binary_search(a, n, target)
   #+END_EXAMPLE
   #+LATEX: \linespread{1.2}
   that searches for =target= in =a[0:n]= using binary search
   algorithm. Let the function return an index =i= such that \hfill
   (/search/)
   #+BEGIN_EXAMPLE
   a[0:i] < target <= a[i:n]
   #+END_EXAMPLE
** Specification
   A function =binary_search()= which takes a sorted array =a[]=, the 
   length =n= and the element to be searched =t= as inputs and returns 
   the index to the calling function.
** Prototype
#+BEGIN_EXAMPLE
int binary_search(int a[], int t, int n)
#+END_EXAMPLE
** Program Design
   The program consists of a function =binary_search(int a[], int t, int n)=
   which returns an index based on the condition, and =main()=, which gets
   the input from =stdin=, calls the function and prints the value on =stdout=.
** Algorithm
#+BEGIN_EXAMPLE
def binary_search(a[],t,n):
   b,e=0,n
   while b!=e:
      m=(b+e)/2
      if a[m]<t:
         b=m+1
      else:
         e=m
   return b
#+END_EXAMPLE
** Source Code
#+BEGIN_SRC C :cmdline <binary.in
  #include<stdio.h>
  int binary_search(int a[], int t, int n){
    int b=0,e=n,m;
    while(b!=e){
      m=(b+e)/2;
      if(a[m]<t)
	b=m+1;
      else
	e=m;
    }
    return b;
  }
  int main(){
    int a[20],n,t;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
      scanf("%d",&a[i]);
    }
    scanf("%d",&t);
    int m=binary_search(a,t,n);
    printf("%d",m);
  }
#+END_SRC
** Test Input
#+BEGIN_EXAMPLE
10
0 10 12 21 24 39 45 53 75 89
14
#+END_EXAMPLE
** Output
#+RESULTS:
: 3
* Selection sort 
   Selection sort is an algorithm for sorting an
   array of items, say =a[0:n]=. The idea of the algorithm is
   expressed below:
   #+LATEX:  \linespread{1}
   #+NAME: selsort

   #+BEGIN_EXAMPLE
   swap a[0], a[minimum(a,0,n)]
   swap a[1], a[minimum(a,1,n)]
   swap a[2], a[minimum(a,2,n)]
   ...
   swap a[n-2], a[minimum(a,n-2,n)]   
   #+END_EXAMPLE
   which uses =minimum(a, i, n)= to find the minimum of a subarray
   =a[i:n]=.
   #+BEGIN_EXAMPLE
   selection_sort (a, 0, n):
      for i = 0 to n-2:
         swap a[i], a[minimum(a, i, n)]   
   #+END_EXAMPLE
   #+latex: \linespread{1.2}
   Implement selection sort, using =minimum()= function. Note:
   remember that when a function changes the items of an array
   parameter, the changes are effected in the items of the actual
   array argument also.

   Test the function from =main()= for several lists of numbers. Each
   test should read a list of numbers from stdin.
** Specification
   2 functions =min()=, which takes array =a[]=, start index =l=, and 
   end index =h= as inputs and returns the index of smallest number,
   and =selection_sort()=, which takes array =a[]=, length =n= as 
   inputs and sorts the array in ascending order.
** Prototype
#+BEGIN_EXAMPLE
int min(int a[], int l, int h)
void selection_sort(int a[], int n)
#+END_EXAMPLE
** Program Design
   The progam consists of 2 functions =min(int a[], int l, int h)=, 
   which finds the index of the smallest number of the array within
   l and h and returns it, =selection_sort(int a[], int n)=, which
   sorts the array in ascending order, and =main()=, which gets the 
   input from =stdin=, calls the function and prints the output on =stdout=.
** Algorithm
#+BEGIN_EXAMPLE
def min(a[],l,h):
   p=l
   for i in range(l,h):
      if a[i]<a[p]:
         p=i
   return p
def selection_sort(a[],n):
   for i in range(n):
      m=min(a,i,n)
      a[i],a[m]=a[m],a[i]
#+END_EXAMPLE
** Source Code
#+BEGIN_SRC C :cmdline <selsort.in
  #include<stdio.h>
  int min(int a[], int l, int h){
    int p=l;
    for(int i=l;i<h;i++){
      if(a[i]<a[p])
	p=i;
    }
    return p;
  }
  void selection_sort(int a[], int n){
    int m,t;
    for(int i=0;i<n;i++){
      m=min(a,i,n);
      t=a[i];
      a[i]=a[m];
      a[m]=t;
    }
  }
  int main(){
    int a[20],n;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
      scanf("%d",&a[i]);
    }
    selection_sort(a,n);
    for(int i=0;i<n;i++){
      printf("%d ",a[i]);
    }
  }
#+END_SRC
** Test Input
#+BEGIN_EXAMPLE
11 12 1 6 67 34 15 23 56 32
#+END_EXAMPLE
** Output
   #+RESULTS:
   : 1 6 11 12 15 23 32 34 56 67

* Polish National Flag (PNF)
   In an array of items =a[low:high]=,
   each item is either positive or negative. Define a function
   =partition(a, low, high)= that partitions the array into two
   subarrays =a[low:i]= and =a[i:high]= such that all the negative
   items of the array form =[low:i]=, and all the positive items form
   =[i:high]=. Test the function from =main()=. Use several lists of
   numbers for testing. (Note: We will use this algorithm for
   implementing =quicksort()=.)

** Specification
   A function =pnf()=, which takes array =a[l:h]= as input and 
   returns the index of the last negative number in the new array.
** Prototype
#+BEGIN_EXAMPLE
int pnf(int a[], int l, int h)
#+END_EXAMPLE
** Program Design
   The program has a function =pnf(int a[], int l, int h)= which
   returns the index of the last negative number in the new array,
   and =main()=, which gets the input from =stdin=, calls the function
   and prints the value on =stdout=.
** Algorithm
#+BEGIN_EXAMPLE
def pnf(a[],low,high):
   i,p=l,l
   while i<h:
      if a[i]<0:
         a[i],a[p]=a[p],a[i]
         p+=1
      i+=1
   return p
#+END_EXAMPLE
   
#+LATEX: \linespread{1}
** Source Code
#+BEGIN_SRC C :cmdline <pnf.in
  #include<stdio.h>
  int pnf(int a[], int l, int h){
    int i=l,p=l;
    while(i<h){
      if(a[i]<0){
	int t=a[i];
	a[i]=a[p];
	a[p]=t;
	p++;
      }
      i++;
    }
    return p;
  }
  int main(){
    int a[20],n;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
      scanf("%d",&a[i]);
    }
    printf("\n");
    int p=pnf(a,0,n);
    for(int j=0;j<p;j++){
      printf("%d ",a[j]); 
    }
    printf("\n");
    for(int j=p;j<n;j++){
      printf("%d ",a[j]);
    }
  }

#+END_SRC
** Test Input
#+BEGIN_EXAMPLE
20 -8 56 45 -90 21 -7 1 -3 5
#+END_EXAMPLE
** Output
   #+RESULTS:
   | -8 | -90 | -7 | -3 |     |    |    |   |    |   |
   | 20 |  21 | 56 |  1 |  45 |  5 |    |   |    |   |

* Dutch National Flag (DNF)  
   Dutch National Flag (DNF) is similar to PNF, but partitions the
   array =a[l:h]= into three subarrays =[l:i]=, =[i:j]= and
   =[j:h]=. Each item of the array has one of the three
   properties. Items having the same property should form one subarray
   each.
** Specification
   2 functions =print(a[l:h])=, used to print the array, =dnf()=
   which takes array =a[l:h]= and =c= as inputs and arrange the array
   based on =c=.
** Prototype
#+BEGIN_EXAMPLE
void print(char a[], int l, int h)
int dnf(char a[], int l, int h, char c)
#+END_EXAMPLE
** Program Design
   The program contains 2 functions =print(char a[], int l, int h)=,
   which prints the array, =dnf(char a[], int l, int h, char c)=, which
   returns the index upto which the array has been rearranged, and =main()=
   which gets input from =stdin= and calls the functions.
** Algorithm
#+BEGIN_EXAMPLE
def print(a[],l,h):
   for i in range(l,h):
      print(a[i])
def dnf(a[],l,h,c):
   i,p=l,l
   while i<h:
      if a[i]==c:
         a[i],a[p]=a[p],a[i]
         p+=1
      i+=1
#+END_EXAMPLE
** Source Code
#+BEGIN_SRC C :cmdline <dnf.in
  #include<stdio.h>
  #include<string.h>
  void print(char a[], int l, int h){
    for(int i=l;i<h;i++){
      printf("%c ",a[i]);
    }
  }
  int dnf(char a[], int l, int h, char c){
    int i=l,p=l;
    while(i<h){
      if(a[i]==c){
	char t=a[i];
	a[i]=a[p];
	a[p]=t;
	p++;
      }
      i++;
    }
    return p;
  }
  int main(){
    char a[50],c,d;
    int n,p,q;
    scanf("%s",a);
    n=strlen(a);
    scanf("%c%c",&c,&d);
    printf("\n");
    p=dnf(a,0,n,c);
    print(a,0,p);  
    printf("\n");
    q=dnf(a,p,n,d);
    print(a,p,q); 
    printf("\n");
    print(a,q,n);
    printf("\n");
  }
#+END_SRC
** Test Input
#+BEGIN_EXAMPLE
aaaaabbbccbbccaccacbbac
b
c
#+END_EXAMPLE
** Output
#+RESULTS:
| b | b | b | b | b | b | b |   |   |   |   |   |   |   |   |   |
| a | c | c | a | a | c | c | a | c | c | a | c | a | a | a | c |
*Ex06*
